\chapter{Detalles de Implementaci√≥n y Experimentos}\label{chapter:implementation}

\todo[inline]{@TODO introduce y enlaza las cosas}

Se implement\'o un contrato inteligente en el lenguaje de programaci\'on Solidity. 

Existen tres roles en el sistema: 
\begin{enumerate}
    \item usuario: puede consultar la informaci\'on p\'ublica del sistema. Toda persona posee este rol.
    \item votante: puede votar por un candidato. 
    \item due\~no: es el creador del contrato y tiene acceso a sus funcionalidades administrativas. Es el \'unico capaz de otorgar el rol votante a otra persona e incluso, a s\'i mismo. 
\end{enumerate}

Funcionalidades del contrato:
\begin{itemize}
    \item registro de votantes: el due\~no puede registrar a los votantes cuando crea el contrato. Para ello, debe proveer las direcciones p\'ublicas de Ethereum de los votantes. El sistema le asigna un identificador (ID) a cada votante. Consiste en un entero no negativo menor que la cantidad de votantes registrados y se corresponde con el \'indice del votante en la lista dada por el due\~no. A lo largo de la implementaci\'on de las funcionalidades del contrato, se utiliza el ID, en lugar de la direcci\'on p\'ublica, como forma  de representaci\'on del votante. \todo{@TODO decir xq?}
    \item registro de un voto por parte del votante: un votante puede votar por un candidato. Para ello, debe proveer la direcci\'on p\'ublica de Ethereum del candidato. No se permite el doble voto.
    \item registro de un voto por parte del due\~no: el due\~no puede registrar un voto, aun cuando \'el no sea el votante o el candidato en cuesti\'on. Para ello, debe proveer el identificador del votante y el identificador del candidato. No se permite el doble voto.
    \item conteo de votos: todo usuario puede consultar en cualquier momento la informaci\'on actualizada del conteo de votos.  La respuesta a la consulta es un arreglo \lstinline{count} de enteros no negativos, donde \lstinline{count[id]} es el n\'umero de votos obtenido por el candidato cuyo identificador es \lstinline{id}. Para obtener este resultado no se realiza el proceso de desempate, por lo que puede existir m\'as de un candidato con el mayor n\'umero de votos.  \todo{@audit el sistema aki'  es +- justo xq el tipo tiene q conocer el id}
    \item consultar qui\'en es el ganador:  todo usuario puede consultar en cualquier momento qui\'en es el ganador de la votaci\'on. El sistema realiza el conteo de votos y, de ser necesario, ejecuta el algoritmo de desempate por IRV (secci\'on~\ref{sec:irv+time-untie}). \todo{@audit el sistema no es justo}
    \item destruir el contrato: el due\~no puede destruir el contrato. Esto imposibilita un uso posterior de cualquiera de sus funcionalidades. 
\end{itemize}

\todo[inline]{@TODO di lo d q el usuario debe conocer el id de un candidato si kiere saber su conteo en cualkier momento}

\section{Conteo de Votos}
Se implement\'o la idea propuesta en la secci\'on~\ref{sec:dfs-counting}. Se almacena la lista de adyacencia del grafo $G$ en el estado del contrato y se modifica cada vez que se registra un voto. La funci\'on $f$ es calculada en la implementaci\'on de \dfsvisitcaption: cada vez que se visita el arco $\langle u, v \rangle$, se a\~nade el arco $\langle v, u \rangle$ a $f$. Consultar el valor de $f(x)$ es $O(1)$. El conjunto $B$ se implementa mediante una lista en la que agregar un elemento y consultar en una posici\'on toma $O(1)$. De esta forma, se satisfacen todas las hip\'otesis de la secci\'on~\ref{sec:dfs-counting:time}. Luego, el conteo se realiza en tiempo $O(n)$, donde $n$ es el n\'umero de votantes registrados.

\section{Desempate}
El registro del tiempo de voto de un votante se realiza empleando un contador global. Inicialmente, su valor es $0$. Cuando se registra el voto de $x$, se incrementa el contador y se toma su valor como el tiempo en que $x$ vot\'o. Es as\'i como se implementa la funci\'on de tiempo $t$, empleada en el mecanismo propuesto de desempate. Las caracter\'isticas que  poseen la tecnolog\'ia \textit{blockchain}  y los algoritmos de consenso, aseguran con alt\'isima probabilidad que el tiempo asignado a cada votante sea \'unico. \todo{@TODO cita} Luego, se puede dar por satisfecha la hip\'otesis del corolario~\ref{corollary:irv}.

Para obtener en cada ronda el candidato a eliminar, se implement\'o la estructura de datos \textit{heap de m\'inimos} \citep{intro-to-algo-3}. Un candidato es ``menor'' que otro si posee menor cantidad de votos en IRV. Si ambos poseen la misma cantidad, entonces es menor el que mayor de $t_{ronda}$ tenga. El \textit{heap} implementado permite modificaciones en los votos, ya que es necesario actualizarlos cuando se elimina un candidato. Todas las operaciones sobre la estructura de datos se realizan en tiempo $O(\log n)$.

Para actualizar los votos cuando se elimina un candidato, es necesario consultar el primer lugar de los \textit{rankings} de ciertos votantes. Estas consultas las satisface una estructura de datos que mantiene actualizado los \textit{rankings} a demanda. Cuando se consulta el primer lugar del \textit{ranking} de $x$, la estructura se desplaza por el grafo $G'$ desde $x$ mediante sucesivas aplicaciones de la funci\'on $f$. Cuando encuentra a un candidato v\'alido, lo reporta y mueve las referencias desde todos los v\'ertices recorridos hacia ese candidato. De esta manera, futuras consultas del primer lugar del \textit{ranking} de alguno de esos candidatos ser\'an satisfechas en menor tiempo. Esta heur\'istica es conocida como \textit{compresi\'on del camino} o \textit{path compression} \citep{intro-to-algo-3}. \todo{@TODO no estari'a mal una figura o un ejemplo} Un v\'ertice intermedio en el camino entre el votante y su candidato v\'alido no se visita dos veces durante la resoluci\'on de todas las consultas. Por ende, el costo total del empleo de la estructura de datos es $O(n)$.

Por decisiones de implementaci\'on, puede que en un momento dado se haya alcanzado la mayor\'ia de  votos por parte del candidato a la cabeza y, sin embargo, el algoritmo siga iterando sin declararlo ganador. En el peor de los casos, el algoritmo realiza $n$ iteraciones, eliminando en cada una a un candidato en tiempo $O(\log n)$ y consultando el primer lugar del \textit{ranking} de algunos candidatos. Luego, el costo total del algoritmo de desempate es $O(n \log n)$.

\section{Despliegue}
El contrato fue desplegado en una red GoQuorum versi\'on 22.4.4 en Kaleido,  \todo{@TODO cita kaleido} con LBFT como protocolo de consenso.  \todo{@TODO cita LBFT. X ahi' anda el paper} La red est\'a formada por dos nodos no firmantes y un nodo monitor firmante. Cada uno de ellos con sistema operativo Linux, arquitectura AMD64 y versi\'on de Go 1.16.15. Se encuentran ubicados en la zona este de Estados Unidos  y son mantenidos por Servicios Web de Amazon (AWS).  Poseen 1 GB de RAM y utilizan la mitad del CPU virtual asignado. \todo{@TODO explik lo del vcpu}  Tambi\'en se cre\'o una billetera en Kaleido con m\'as de 100 cuentas. 

Se ejecut\'o un caso de prueba de 100 votantes. Se compil\'o el contrato con \texttt{solc} versi\'on 0.8.17, habilitando el optimizador  con el par\'ametro \lstinline{--optimize-runs=20}. 
\todo[inline]{@TODO ak\'i habla  d xq' 20 y una posible excusa puede ser el promedio d los votantes. Lo de abajo no va en un pa'rrafo aparte}
El \textit{bytecode} de creaci\'on del contrato ocup\'o apr\'oximadamente 13.7 KB.  Al contar los votos,   21 candidatos resultan empatados en el primer lugar con un total de 30 votos cada uno.   Desde que se consult\'o por el ganador de la votaci\'on hasta que se obtuvo una respuesta  satisfactoria, transcurrieron 300 milisegundos apr\'oximadamente y se consumieron 92857 unidades de \textit{gas}.  Todos los pedidos web se realizaron a un mismo destino, el cual consumi\'o un 2\% de su CPU y elev\'o su consumo de RAM en 29 MB. El uso de CPU y RAM de los nodos se mantuvo relativamente constante. El uso del disco tampoco vari\'o en gran medida. 

% @remind El servidor en el que se encontraba la billetera consumi\'o un 2\% del CPU, ya que todos los pedidos fueron pa all\'a. Los nodos mantuvieron su cpu al 4\%. El consumo normal de la wallet es d 100mb de ram y cuan2 c lanzaron los pedidos alcanz\'o un pico de 129mb. los nodos mantuvieron un uso d ram d 500mb approx. El uso del disco tampoco vari\'o en gran medida.  El gas consumido por el getwinner fue de 92857
