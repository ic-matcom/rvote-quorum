\chapter{Detalles de ImplementaciÃ³n y Experimentos}\label{chapter:implementation}

% @audit no se' si esto vaya aki' o en el capi'tulo de la  propuesta


\section{Conteo de Votos}
Sean $V$ el conjunto de los participantes  de la elecci\'on (votantes) y $f \in V \times V$ la relaci\'on de voto, esto es, $ \langle x, y \rangle \in f $ si y s\'olo si $x$ vot\'o por $ y $.  Se asume que culmin\'o el registro de todos los votos y que s\'olo existen votos v\'alidos. Cada votante puede elegir a lo sumo a otra persona, por ende, $f$ es funci\'on.

Sea $G' = \langle V, f \rangle$ el digrafo de votaci\'on. Representaciones de este grafo pueden ser encontradas en las figuras \ref{fig:r-voting} y \ref{fig:voting-cycle}.

Ahora bien, sea $G = \langle V, f^{-1} \rangle$. Se denota por $G_\pi$ al subgrafo de predecesores del DFS \citep{intro-to-algo-3}. El conteo de los votos obtenidos por $x$ se reduce a contar la cantidad de nodos en el sub\'arbol de $x$ en $G_\pi$.  % @TODO demostrarlo

El conteo de los votos puede ser implementado mediante DFS. En este sentido, los algoritmos \ref{algo:dfs} y \ref{algo:dfs-visit} constituyen adaptaciones   a las propuestas de DFS y DFS-Visit de \cite{intro-to-algo-3}, respectivamente. Se asume que $G$ se encuentra representado mediante listas de adyacencia. En $B$ se almacenan los arcos de retroceso de $G$, los cuales ser\'an empleados posteriormente para asignar los votos a los v\'ertices que se encuentran en alg\'un ciclo.  Una vez el algoritmo \ref{algo:dfs} termine, en $u.votes$ se tendr\'a la cantidad de votos obtenidos por el votante representado mediante el v\'ertice $u$.

\begin{algorithm}[!h]
    \caption{DFS-Votes}
    \label{algo:dfs}
    \DontPrintSemicolon
    \SetAlgoLined
    \Entrada{Grafo $G = \langle V, f^{-1} \rangle$.}
    \BlankLine

    \ForEach{v\'ertice $u \in G.V$}{
        $u.color =$ WHITE\;
        $u.\pi =$ NIL\;
        $u.votes = 0$\;
    }
    $B = \{\}$\;
    \ForEach{v\'ertice $u \in G.V$}{
        \If{$u.color == $ {\rm WHITE}}{
            DFS-Visit-Votes($G, u, B$)\;
        }
    }
    Set-Votes-In-Cycles($G, B$)\; \label{algo:dfs:line:votes-in-cycles}
\end{algorithm}

% @FIXME el pseudoco'digo tiene los keywords en espanyol, considerar q las variables lo este'n tambie'n

El algoritmo \ref{algo:dfs} difiere en muy pocos aspectos al de \cite{intro-to-algo-3}. Uno de los m\'as significativos es el llamado a la funci\'on Set-Votes-In-Cycles en la l\'inea \ref{algo:dfs:line:votes-in-cycles}. Esta funci\'on se encarga de asignar los votos a los v\'ertices que se encuentran en alg\'un ciclo.  

El algoritmo \ref{algo:dfs-visit} calcula los votos obtenidos por $u$ y a\~nade a $B$ los arcos de retroceso encontrados durante el proceso.

\begin{algorithm}[!h]
    \caption{DFS-Visit-Votes}
    \label{algo:dfs-visit}
    \DontPrintSemicolon
    \SetAlgoLined
    \Entrada{Grafo $G$; v\'ertice $u$; conjunto $B$ de arcos de retroceso.}     
    \BlankLine

    $u.color =$ GRAY\;

    \ForEach{$v \in G.Adj[u]$}{ \label{algo:dfs-visit:line:arc-foreach}
        \If{$v.color ==$ {\rm WHITE}}{
            $v.\pi = u$\;
            DFS-Visit-Votes($G, v, B$)\;
        }\lElse{\If{$v.color ==$ {\rm GRAY}}{
            $B = B \cup \{\langle u, v \rangle\}$\; \label{algo:dfs-visit:line:add-B}
        }}
        \If{$v.color ==$ {\rm BLACK}}{ \label{algo:dfs-visit:line:if-black}
            $u.votes = u.votes + v.votes + 1$\; \label{algo:dfs-visit:line:votes}
        }
    }
    $u.color =$ BLACK\;
\end{algorithm}

El \textbf{foreach} de las l\'ineas \ref{algo:dfs-visit:line:arc-foreach}-\ref{algo:dfs-visit:line:votes} itera por todos los arcos salientes de $u$. N\'otese que $v \in G.Adj[u]$ si y s\'olo si $v$ vot\'o por $u$, por definici\'on de $G$.  Se a\~nade un nuevo arco de retroceso a $B$ en la l\'inea \ref{algo:dfs-visit:line:add-B}. Un arco $\langle u, v \rangle$ es de retroceso si y s\'olo si $v$ es gris cuando se explora ese arco por primera vez \citep{intro-to-algo-3}. El n\'umero de votos obtenidos por $u$ es actualizado solamente en la l\'inea \ref{algo:dfs-visit:line:votes}, cuando $v$ es negro. Esto se debe a que los votos obtenidos por $v$ se encuentran bien calculados cuando es negro. Todos los votos obtenidos por $v$, m\'as el voto que este le confiere a $u$, son contados como votos de  $u$. N\'otese que el bloque de las l\'ineas \ref{algo:dfs-visit:line:if-black}-\ref{algo:dfs-visit:line:votes} es un \textbf{if}, y no un \textbf{else if}. Esto es intencional y permite que se actualicen los votos de $u$ correctamente, incluso cuando $\langle u, v \rangle$ es un arco de \'arbol de $G_\pi$.

% @TODO probar q cuan2 v es negro entonces los votos d v esta'n bien contados

El algoritmo \ref{algo:votes-cycles} itera por todos los ciclos de $G$. En cada ciclo, calcula el mayor n\'umero de votos obtenidos por un v\'ertice del ciclo y le asigna esa cantidad a los restantes v\'ertices del ciclo. Los votantes de un mismo ciclo conf\'ian indirectamente entre ellos dos a dos, por ende, se considera justo que cada uno de ellos obtenga la misma cantidad de votos, y que esta sea la mayor obtenida por un miembro del ciclo.

\begin{algorithm}[!h]
    \caption{Set-Votes-In-Cycles}
    \label{algo:votes-cycles}
    \DontPrintSemicolon
    \SetAlgoLined
    \Entrada{Grafo $G$; conjunto $B$ de arcos de retroceso.}     
    \BlankLine

    \ForEach{$\langle u, v \rangle \in B$}{
        $m = v.votes$\;
        $x = u$\;
        \While{$x \neq v$}{
            $m = \max(m, x.votes)$\;
            $x = x.\pi$\;
        }
        $x = u$\;
        \While{$x \neq v$}{
            $x.votes = m$\;
            $x = x.\pi$\;
        }
        $v.votes = m$\;
    }
\end{algorithm}

% @TODO hay q probar q c esta'n considerando todos los ciclos

\section{Implementaci\'on del Desempate}
Sean $m = \max\{ u.votes \;|\; u \in V \}$ y $W = \{ u \in V \;|\; u.votes = m \}$.  Para determinar un ganador cuando $|W| > 1$, se emplea una adaptaci\'on del m\'etodo de desempate instant\'aneo. 

Sea $x \in V$ un v\'ertice cualquiera de $G'$. Sea $P(x)$ un camino simple maximal de $G'$ que comienza en $x$. Luego,
$$
P(x) = \langle x, f(x), f(f(x)), \ldots, f^{k}(x) \rangle.
$$
Como $f$ es funci\'on, entonces $P(x)$ es \'unico. 

Sea $D$ el conjunto de los votantes que han sido eliminados por el m\'etodo de desempate. El \textit{ranking} de $x$ se define como  la subsecuencia maximal de $P(x)$ de v\'ertices que est\'an en $W$ y que no est\'an en $D \cup \{ x \}$. 
% Formalmente, el \textit{ranking} de $x$ es
% $$
% R(x) = \langle y_{i_1}, y_{i_2}, \ldots, y_{i_t} \rangle, \quad 1 \leq i_1 \leq i_2 \leq \ldots \leq i_t \leq k, \quad y_{i_j} \in W \setminus D, \; 1 \leq \forall j \leq t.
% $$
Sea $x \in V$ un v\'ertice cualquiera de $G'$. Sea $P(x)$ un camino simple maximal de $G'$ que comienza en $x$. Luego,
$$
P(x) = \langle x, f(x), f(f(x)), \ldots, f^{k}(x) \rangle.
$$
Como $f$ es funci\'on, entonces $P(x)$ es \'unico. 

Sea $D$ el conjunto de los votantes que han sido eliminados por el m\'etodo de desempate. El \textit{ranking} de $x$ se define como  la subsecuencia maximal de $P(x)$ de v\'ertices que est\'an en $W$ y que no est\'an en $D \cup \{ x \}$. 
% Formalmente, el \textit{ranking} de $x$ es
% $$
% R(x) = \langle y_{i_1}, y_{i_2}, \ldots, y_{i_t} \rangle, \quad 1 \leq i_1 \leq i_2 \leq \ldots \leq i_t \leq k, \quad y_{i_j} \in W \setminus D, \; 1 \leq \forall j \leq t.
% $$