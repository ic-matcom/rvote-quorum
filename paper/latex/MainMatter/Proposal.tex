\chapter{Propuesta}\label{chapter:proposal}

\newcommand{\dfscaption}{\hyperref[algo:dfs]{DFS-Votos}}
\newcommand{\cyclevotescaption}{\hyperref[algo:votes-cycles]{Reasignar-Votos-en-Todos-los-Ciclos}}
\newcommand{\dfsvisitcaption}{\hyperref[algo:dfs-visit]{DFS-Votos-Visita}}
\newcommand{\initdfsvertices}{\hyperref[algo:init-dfs-vertices]{Inicializar-Propiedades-de-V\'ertices}}
\newcommand{\maxincyclecaption}{\hyperref[algo:max-in-cycle]{M\'ax-Votos-en-Ciclo}}
\newcommand{\setvotestoallincyclecaption}{\hyperref[algo:set-votes-all-in-cycle]{Reasignar-Votos-en-Ciclo}}

\section{Conteo de Votos}
Sean $V$ el conjunto de los participantes  de la elecci\'on (votantes) y $f \in V \times V$ la relaci\'on de voto, esto es, $ \langle x, y \rangle \in f $ si y s\'olo si $x$ vot\'o por $ y $.  Se asume que culmin\'o el registro de todos los votos y que s\'olo existen votos v\'alidos. Cada votante puede elegir a lo sumo a otra persona, por ende, $f$ es funci\'on.

Sea $G' = \langle V, f \rangle$ el digrafo de votaci\'on. Representaciones de este grafo pueden ser encontradas en las figuras \ref{fig:r-voting} y \ref{fig:voting-cycle}.

Ahora bien, sea $G = \langle V, f^{-1} \rangle$. Se denota por $G_\pi$ al subgrafo de predecesores del DFS \citep{intro-to-algo-3}. El conteo de los votos obtenidos por $x$ se reduce a contar la cantidad de nodos en el sub\'arbol de $x$ en $G_\pi$. \todo{@TODO demostrarlo}

El conteo de los votos puede ser implementado mediante DFS. En este sentido, los algoritmos \ref{algo:dfs} y \ref{algo:dfs-visit} constituyen adaptaciones   a las propuestas de DFS y DFS-Visit de \cite{intro-to-algo-3}, respectivamente. Se asume que $G$ se encuentra representado mediante listas de adyacencia. En $B$ se almacenan los arcos de retroceso de $G$, los cuales ser\'an empleados posteriormente para asignar los votos a los v\'ertices que se encuentran en alg\'un ciclo.  Una vez el algoritmo \ref{algo:dfs} termine, en $u.votos$ se tendr\'a la cantidad de votos obtenidos por el votante representado mediante el v\'ertice $u$.

\begin{algorithm}[!h]
    \caption{\dfscaption}
    \label{algo:dfs}
    \DontPrintSemicolon
    \SetAlgoLined
    \Entrada{Grafo $G = \langle V, f^{-1} \rangle$.}
    \BlankLine

    \initdfsvertices($G.V$)\;
    $B = \{\}$\;
    \ForEach{v\'ertice $u \in G.V$}{
        \If{$u.color == $ {\rm BLANCO}}{
            \dfsvisitcaption($G, u, B$)\;
        }
    }
    \cyclevotescaption($G, B$)\; \label{algo:dfs:line:votes-in-cycles}
\end{algorithm}

\begin{algorithm}[!h]
    \caption{\initdfsvertices}
    \label{algo:init-dfs-vertices}
    \DontPrintSemicolon
    \SetAlgoLined
    \Entrada{Conjunto de v\'ertices $V$.}
    \BlankLine

    \ForEach{v\'ertice $u \in V$}{
        $u.color =$ BLANCO\;
        $u.candidato =$ NIL\;
        $u.votos = 0$\;
    }
\end{algorithm}

El algoritmo \ref{algo:dfs} difiere en muy pocos aspectos al de \cite{intro-to-algo-3}. Uno de los m\'as significativos es el llamado a la funci\'on Set-Votes-In-Cycles en la l\'inea \ref{algo:dfs:line:votes-in-cycles}. Esta funci\'on se encarga de asignar los votos a los v\'ertices que se encuentran en alg\'un ciclo.  

El algoritmo \ref{algo:dfs-visit} calcula los votos obtenidos por $u$ y a\~nade a $B$ los arcos de retroceso encontrados durante el proceso.

\begin{algorithm}[!h]
    \caption{\dfsvisitcaption}
    \label{algo:dfs-visit}
    \DontPrintSemicolon
    \SetAlgoLined
    \Entrada{Grafo $G$; v\'ertice $u$; conjunto $B$ de arcos de retroceso.}     
    \BlankLine

    $u.color =$ GRIS\;

    \ForEach{$v \in G.Adj[u]$}{ \label{algo:dfs-visit:line:arc-foreach}
        $v.candidato = u$\;
        \If{$v.color ==$ {\rm BLANCO}}{
            \dfsvisitcaption($G, v, B$)\;
        }\lElse{\If{$v.color ==$ {\rm GRIS}}{
            $B = B \cup \{\langle u, v \rangle\}$\; \label{algo:dfs-visit:line:add-B}
        }}
        \If{$v.color ==$ {\rm NEGRO}}{ \label{algo:dfs-visit:line:if-black}
            $u.votos = u.votos + v.votos + 1$\; \label{algo:dfs-visit:line:votes}
        }
    }
    $u.color =$ NEGRO\;
\end{algorithm}

El \textbf{foreach} de las l\'ineas \ref{algo:dfs-visit:line:arc-foreach}-\ref{algo:dfs-visit:line:votes} itera por todos los arcos salientes de $u$. N\'otese que $v \in G.Adj[u]$ si y s\'olo si $v$ vot\'o por $u$, por definici\'on de $G$.  Se a\~nade un nuevo arco de retroceso a $B$ en la l\'inea \ref{algo:dfs-visit:line:add-B}. Un arco $\langle u, v \rangle$ es de retroceso si y s\'olo si $v$ es gris cuando se explora ese arco por primera vez \citep{intro-to-algo-3}. El n\'umero de votos obtenidos por $u$ es actualizado solamente en la l\'inea \ref{algo:dfs-visit:line:votes}, cuando $v$ es negro. Esto se debe a que los votos obtenidos por $v$ se encuentran bien calculados cuando es negro. Todos los votos obtenidos por $v$, m\'as el voto que este le confiere a $u$, son contados como votos de  $u$. N\'otese que el bloque de las l\'ineas \ref{algo:dfs-visit:line:if-black}-\ref{algo:dfs-visit:line:votes} es un \textbf{if}, y no un \textbf{else if}. Esto es intencional y permite que se actualicen los votos de $u$ correctamente, incluso cuando $\langle u, v \rangle$ es un arco de \'arbol de $G_\pi$.

\todo[inline]{@TODO probar q cuan2 v es negro entonces los votos d v esta'n bien contados}

El algoritmo \ref{algo:votes-cycles} itera por todos los ciclos de $G$. En cada ciclo, calcula el mayor n\'umero de votos obtenidos por un v\'ertice del ciclo y le asigna esa cantidad a los restantes v\'ertices del ciclo. Los votantes de un mismo ciclo conf\'ian indirectamente entre ellos dos a dos, por ende, se considera justo que cada uno de ellos obtenga la misma cantidad de votos, y que esta sea la mayor obtenida por un miembro del ciclo.

\begin{algorithm}[!h]
    \caption{\cyclevotescaption}
    \label{algo:votes-cycles}
    \DontPrintSemicolon
    \SetAlgoLined
    \Entrada{Grafo $G$; conjunto $B$ de arcos de retroceso.}     
    \BlankLine

    \ForEach{$\langle u, v \rangle \in B$}{
        $m = $ \maxincyclecaption($\langle u, v \rangle$)\;
        \setvotestoallincyclecaption($m, \langle u, v \rangle$)\;
    }
\end{algorithm}

\todo[inline]{@TODO hay q probar q c esta'n considerando todos los ciclos}

\begin{algorithm}[!h]
    \caption{\maxincyclecaption}
    \label{algo:max-in-cycle}
    \DontPrintSemicolon
    \SetAlgoLined
    \Entrada{Arco de retroceso $\langle u, v \rangle$.}     
    \Salida{Mayor n\'umero de votos obtenidos por un v\'ertice del ciclo.}
    \BlankLine

    $m = v.votos$\;
    $x = u$\;
    \While{$x \neq v$}{
        $m = \max(m, x.votos)$\;
        $x = x.candidato$\;
    }
    \Return{$m$}\;
\end{algorithm}

\todo[inline]{@TODO probar q el ciclo de los algoritmos \ref{algo:set-votes-all-in-cycle} y \ref{algo:max-in-cycle} termina}

\begin{algorithm}[!h]
    \caption{\setvotestoallincyclecaption}
    \label{algo:set-votes-all-in-cycle}
    \DontPrintSemicolon
    \SetAlgoLined
    \Entrada{$m$ votos a asignar; arco de retroceso $\langle u, v \rangle$.}     
    \BlankLine

    $x = u$\;
    \While{$x \neq v$}{
        $x.votos = m$\;
        $x = x.candidato$\;
    }
    $v.votos = m$\;
\end{algorithm}



\section{Implementaci\'on del Desempate}
Sean $m = \max\{ u.votos \;|\; u \in V \}$ y $W = \{ u \in V \;|\; u.votos = m \}$.  Para determinar un ganador cuando $|W| > 1$, se emplea una adaptaci\'on del m\'etodo de desempate instant\'aneo. 

Sea $x \in V$ un v\'ertice cualquiera de $G'$. Sea $P(x)$ un camino simple maximal de $G'$ que comienza en $x$. Luego,
$$
P(x) = \langle x, f(x), f(f(x)), \ldots, f^{k}(x) \rangle.
$$
Como $f$ es funci\'on, entonces $P(x)$ es \'unico. 

Sea $D$ el conjunto de los votantes que han sido eliminados por el m\'etodo de desempate. El \textit{ranking} de $x$ se define como  la subsecuencia maximal de $P(x)$ de v\'ertices que est\'an en $W$ y que no est\'an en $D \cup \{ x \}$. 
% Formalmente, el \textit{ranking} de $x$ es
% $$
% R(x) = \langle y_{i_1}, y_{i_2}, \ldots, y_{i_t} \rangle, \quad 1 \leq i_1 \leq i_2 \leq \ldots \leq i_t \leq k, \quad y_{i_j} \in W \setminus D, \; 1 \leq \forall j \leq t.
% $$
Sea $x \in V$ un v\'ertice cualquiera de $G'$. Sea $P(x)$ un camino simple maximal de $G'$ que comienza en $x$. Luego,
$$
P(x) = \langle x, f(x), f(f(x)), \ldots, f^{k}(x) \rangle.
$$
Como $f$ es funci\'on, entonces $P(x)$ es \'unico. 

Sea $D$ el conjunto de los votantes que han sido eliminados por el m\'etodo de desempate. El \textit{ranking} de $x$ se define como  la subsecuencia maximal de $P(x)$ de v\'ertices que est\'an en $W$ y que no est\'an en $D \cup \{ x \}$. 
% Formalmente, el \textit{ranking} de $x$ es
% $$
% R(x) = \langle y_{i_1}, y_{i_2}, \ldots, y_{i_t} \rangle, \quad 1 \leq i_1 \leq i_2 \leq \ldots \leq i_t \leq k, \quad y_{i_j} \in W \setminus D, \; 1 \leq \forall j \leq t.
% $$